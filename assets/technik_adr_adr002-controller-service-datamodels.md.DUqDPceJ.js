import{_ as n,D as i,c as t,I as d,j as e,a as r,a2 as l,o as s,a7 as o,a8 as h}from"./chunks/framework.DG8ixlP0.js";const k=JSON.parse('{"title":"Kriterien für shared oder separated Datenmodell zwischen Service und Controller","description":"","frontmatter":{},"headers":[],"relativePath":"technik/adr/adr002-controller-service-datamodels.md","filePath":"technik/adr/adr002-controller-service-datamodels.md"}'),c={name:"technik/adr/adr002-controller-service-datamodels.md"},u=e("h1",{id:"kriterien-fur-shared-oder-separated-datenmodell-zwischen-service-und-controller",tabindex:"-1"},[r("Kriterien für shared oder separated Datenmodell zwischen Service und Controller "),e("a",{class:"header-anchor",href:"#kriterien-fur-shared-oder-separated-datenmodell-zwischen-service-und-controller","aria-label":'Permalink to "Kriterien für shared oder separated Datenmodell zwischen Service und Controller"'},"​")],-1),m=e("h2",{id:"status",tabindex:"-1"},[r("Status "),e("a",{class:"header-anchor",href:"#status","aria-label":'Permalink to "Status"'},"​")],-1),p=l('<h2 id="kontext" tabindex="-1">Kontext <a class="header-anchor" href="#kontext" aria-label="Permalink to &quot;Kontext&quot;">​</a></h2><p>In den Services haben wir unterschiedliche Varianten was die Kopplung der einzelnen Schichten betrifft.</p><p>Diese Unterscheidung halten wir für vertretbar da nicht alle Services gleich aufgebaut sein müssen. Wichtig ist, dass nachvollziehbar ist, welche Variante wann zu bevorzugen ist.</p><h3 id="shared-datenmodell-bei-broadcast-service" tabindex="-1">Shared-Datenmodell bei Broadcast-Service <a class="header-anchor" href="#shared-datenmodell-bei-broadcast-service" aria-label="Permalink to &quot;Shared-Datenmodell bei Broadcast-Service&quot;">​</a></h3><p>Im Broadcast-Service verwenden sowohl Controller als auch Service dasselbe Datenmodell. Der Grund dafür war, dass die Operationen im Service überschaubar sind und das gleiche Modell wie der Controller erfordern. Um die Komplexität und den Code-Umfang nicht ohne Mehrwert zu erhöhen, haben wir uns für die Verwendung der gleichen Klassen in Controller und Service entschieden.</p><h3 id="separated-datenmodell-beim-briefwahl-service" tabindex="-1">Separated-Datenmodell beim Briefwahl-Service <a class="header-anchor" href="#separated-datenmodell-beim-briefwahl-service" aria-label="Permalink to &quot;Separated-Datenmodell beim Briefwahl-Service&quot;">​</a></h3><p>Beim Briefwahl-Service gibt es für Controller und Service jeweils eigene Klassen.</p><p>Dadurch wird ermöglicht, dass im Service Methoden mit nur einem Argument verwendet werden können. Im Controller waren es drei Argumente, die aber zu einer semantischen Einheit gehörten. Im Service ist es nur ein Argument.</p><h2 id="entscheidung" tabindex="-1">Entscheidung <a class="header-anchor" href="#entscheidung" aria-label="Permalink to &quot;Entscheidung&quot;">​</a></h2><p>Grundsätzlich sind mit dem Shared- und Separated-Datenmodell zwei Varianten zur Kopplung von Controller und Service möglich. Die Kriterien dazu sind oben beispielhaft beschrieben.</p><p>Services sollen aber einheitlich aufgebaut sein. Um die Verständlichkeit zu wahren dürfen sich die beiden Varianten innerhalb eines Service nicht vermischen.</p><h3 id="separated-datenmodell-je-layer" tabindex="-1">Separated-Datenmodell je Layer <a class="header-anchor" href="#separated-datenmodell-je-layer" aria-label="Permalink to &quot;Separated-Datenmodell je Layer&quot;">​</a></h3><p><img src="'+o+'" alt="separate models"></p><p>Jeder Layer hat sein eigenes Datenmodell. Der Controller mappt die DTO-Klassen vor Verwendung des Service auf die Model-Klassen. Der Service mappt die Model-Klassen auf die Entity-Klassen des Repository.</p><p>Dieses Vorgehen ist in der Regel zu wählen, sobald im Controller Pathvariablen oder Requestparameter im Kombination mit einem Requestbody auftreten.</p><p>In diesen Fällen werden für die gleiche Semantik jeweils unterschiedliche Datenmodelle verwendet: Mehrere Argumente vs. ein Argument.</p><h3 id="shared-datenmodell-fur-controller-und-service" tabindex="-1">Shared-Datenmodell für Controller und Service <a class="header-anchor" href="#shared-datenmodell-fur-controller-und-service" aria-label="Permalink to &quot;Shared-Datenmodell für Controller und Service&quot;">​</a></h3><p><img src="'+h+'" alt="shared model"></p><p>Controller und Service verwenden die gleichen DTO-Klassen, ergo dasselbe Datenmodell. Es erfolgt hier kein Mapping. Der Service mappt dann die Model-Klassen auf die Entity-Klassen des Repository.</p><p>Kann verwendet werden, wenn Controller und Service das gleiche Datenmodell verwenden. Kein Umorganisieren der Parameter notwendig</p><h2 id="konsequenzen" tabindex="-1">Konsequenzen <a class="header-anchor" href="#konsequenzen" aria-label="Permalink to &quot;Konsequenzen&quot;">​</a></h2><h3 id="negativ" tabindex="-1">negativ <a class="header-anchor" href="#negativ" aria-label="Permalink to &quot;negativ&quot;">​</a></h3><ul><li>zusätzliche Klassen beim Shared-Datenmodell die teilweise identisch sind</li><li>zusätzliches Mapping beim Shared-Datenmodell</li></ul><h3 id="positiv" tabindex="-1">positiv <a class="header-anchor" href="#positiv" aria-label="Permalink to &quot;positiv&quot;">​</a></h3><ul><li>Möglichkeit der Auswahl zwischen den beiden Modellen und dadurch Reduktion der Komplexität beim Shared-Datenmodell</li><li>konsequente Entkopplung der jeweiligen Schichten (Änderung am Service führt nicht zwangsläufig zu einer Änderung der Rest-API) beim Shared-Datenmodell</li><li>bessere innere Kohäsion der Schichten</li><li>bessere Lesbarkeit von Code durch weniger Argumente in Methoden beim Shared-Datenmodell</li></ul>',25);function b(v,g,S,f,w,D){const a=i("adr-status");return s(),t("div",null,[u,m,d(a,{status:"accepted"}),p])}const z=n(c,[["render",b]]);export{k as __pageData,z as default};
